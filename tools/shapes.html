<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shape Matching Game</title>
  <style>
    #game-container {
      width: 100%;
      height: 93vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      background-color: #f0f0f0;
    }

    .shape, .matching-shape {
      width: 100px;
      height: 100px;
      cursor: pointer;
      position: absolute;
    }

    .square {
      background-color: blue;
    }

    .circle {
      background-color: red;
      border-radius: 50%;
    }

    .triangle {
      background-color: green;
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-bottom: 100px solid yellow;
    }

    .confetti {
    position: absolute;
    border-radius: 4px;
    opacity: 1;
    pointer-events: none;
    animation: confetti-fall 2s forwards;
  }

  @keyframes confetti-fall {
    0% {
      transform: translateY(0) translateX(0) scale(1);
      opacity: 1;
    }
    30% {
      transform: translateY(-100px) translateX(var(--random-x)) scale(1.2);
      opacity: 1;
    }
    100% {
      transform: translateY(var(--random-height)) translateX(var(--random-x)) rotate(var(--random-rotate)) scale(0.8);
      opacity: 0;
    }
  }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="shapes-container">
      <div id="shape1" class="shape square" style="top: 100px; left: 100px;"></div>
      <div id="shape2" class="shape circle" style="top: 100px; left: 250px;"></div>
      <div id="shape3" class="shape triangle" style="top: 100px; left: 400px;"></div>
    </div>
    <div id="matching-shapes-container">
      <div id="matching-shape1" class="matching-shape square" style="top: 400px; left: 100px;"></div>
      <div id="matching-shape2" class="matching-shape circle" style="top: 400px; left: 250px;"></div>
      <div id="matching-shape3" class="matching-shape triangle" style="top: 400px; left: 400px;"></div>
    </div>
  </div>

  <script>
    const shapes = document.querySelectorAll('.shape');
    const matchingShapes = document.querySelectorAll('.matching-shape');
    const gameContainer = document.getElementById('game-container');
    let draggedShape = null;
    let offsetX, offsetY;
    let originalX, originalY; // To store the original position of a shape if not dropped correctly

    const emoteClasses = [
    '#FFB3BA', // Pastel Pink
    '#FFDFBA', // Pastel Peach
    '#FFEBBA', // Pastel Yellow
    '#FFFFBA', // Pastel Cream
    '#BAFFC9', // Pastel Mint Green
    '#BAE1FF'  // Pastel Blue
]; // Pastel colors for confetti

function getRandomColor() {
    const randomIndex = Math.floor(Math.random() * emoteClasses.length);
    return emoteClasses[randomIndex];
}


 


    function createConfettiBurst(x, y) {
    for (let i = 0; i < 80; i++) {
        const delay = Math.random() * 50; // Fast burst creation
        setTimeout(() => createConfettiParticle(x, y), delay);
    }
}

function createConfettiParticle(x, y) {
    const confetti = document.createElement('div');
    confetti.classList.add('confetti');

    // Start from the position of the shape with a random vertical offset
    const randomVerticalOffset = Math.random() * 50 + 20; // Height between 20px and 70px above the shape
    confetti.style.left = `${x}px`;
    confetti.style.top = `${y - randomVerticalOffset}px`; // Start above the shape

    const color = getRandomColor();
    confetti.style.backgroundColor = color;

    // Random angle and distance for explosion
    const angle = Math.random() * 2 * Math.PI; // Random angle in radians
    const distance = Math.random() * 150 + 20; // Random distance from 50px to 150px
    const fallDuration = Math.random() * 1.5 + 1; // Fall duration (between 1s and 2.5s)
    const randomSize = Math.random() * 10 + 5; // Size between 5px and 15px

    confetti.style.width = `${randomSize}px`;
    confetti.style.height = `${randomSize}px`;

    // Append to the game container
    gameContainer.appendChild(confetti);

    // Calculate the x and y movement based on the angle
    const xMovement = Math.cos(angle) * distance; // Horizontal movement
    const yMovement = Math.sin(angle) * distance; // Vertical movement

    // Animate the initial explosion
    confetti.animate([
        { transform: `translate(0, 0)` },
        { transform: `translate(${xMovement}px, ${yMovement}px)` } // Move in all directions
    ], {
        duration: fallDuration * 800,
        easing: 'ease-out',
        fill: 'forwards'
    });

    // Gravity simulation: use setInterval to apply gravity after the explosion
    const gravityEffect = setInterval(() => {
        // Get the current top position and increase it to simulate falling
        const currentTop = parseFloat(confetti.style.top);
        confetti.style.top = `${currentTop + 1}px`; // Increase y position to simulate gravity

        // Optional: Stop the effect if it goes beyond a certain height (e.g., bottom of the container)
        if (currentTop > window.innerHeight) {
            clearInterval(gravityEffect);
            confetti.remove(); // Clean up the element once it falls out of view
        }
    }, 15); // Adjust the interval for smoother gravity (20ms for smoothness)

    // Remove the confetti after the initial animation completes
    setTimeout(() => {
        clearInterval(gravityEffect); // Stop gravity effect if still running
        confetti.remove();
    }, fallDuration * 200 + 1200); // Allow time for gravity before removal
}






    // Function to check if two elements overlap
    function checkCollision(shape, matchingShape) {
      const shapeRect = shape.getBoundingClientRect();
      const matchingShapeRect = matchingShape.getBoundingClientRect();

      return !(
        shapeRect.right < matchingShapeRect.left ||
        shapeRect.left > matchingShapeRect.right ||
        shapeRect.bottom < matchingShapeRect.top ||
        shapeRect.top > matchingShapeRect.bottom
      );
    }

    // Function to check if all shapes are matched
    function allShapesMatched() {
      return Array.from(shapes).every((shape) => shape.style.display === 'none');
    }

    // Reset the game
    function resetGame() {
      shapes.forEach((shape, index) => {
        shape.style.left = `${100 + index * 150}px`;
        shape.style.top = '100px';
        shape.style.position = 'absolute';
        shape.style.display = 'block';
      });

      matchingShapes.forEach((shape) => {
        shape.style.display = 'block';
      });
    }

    // Drag and Drop Event Handlers for shapes
    shapes.forEach((shape) => {
      shape.addEventListener('touchstart', handleDragStart);
      shape.addEventListener('mousedown', handleDragStart);

      function handleDragStart(event) {
        event.preventDefault();
        draggedShape = shape;
        shape.style.position = 'absolute';
        shape.style.zIndex = 1;

        // Get mouse/touch position
        if (event.touches) {
          offsetX = event.touches[0].pageX - shape.offsetLeft;
          offsetY = event.touches[0].pageY - shape.offsetTop;
        } else {
          offsetX = event.clientX - shape.offsetLeft;
          offsetY = event.clientY - shape.offsetTop;
        }

        // Store the original position before dragging
        const shapeRect = shape.getBoundingClientRect();
        originalX = shapeRect.left;
        originalY = shapeRect.top;

        // Listen to move and end events
        document.addEventListener('touchmove', handleDragMove);
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('touchend', handleDragEnd);
        document.addEventListener('mouseup', handleDragEnd);
      }

      function handleDragMove(event) {
        event.preventDefault();
        let clientX, clientY;

        // Get mouse/touch position
        if (event.touches) {
          clientX = event.touches[0].pageX;
          clientY = event.touches[0].pageY;
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
        }

        // Prevent moving out of the game container
        const containerRect = gameContainer.getBoundingClientRect();
        const shapeRect = draggedShape.getBoundingClientRect();
        const newX = clientX - offsetX;
        const newY = clientY - offsetY;

        // Ensure the shape stays within the container
        if (newX >= containerRect.left && newX + shapeRect.width <= containerRect.right) {
          draggedShape.style.left = `${newX}px`;
        }
        if (newY >= containerRect.top && newY + shapeRect.height <= containerRect.bottom) {
          draggedShape.style.top = `${newY}px`;
        }
      }

      function handleDragEnd(event) {
        // Position the shape at where it was dropped
        const matchingShape = Array.from(matchingShapes).find(ms => ms.classList.contains(shape.classList[1]) && ms.style.display !== 'none');

        if (matchingShape && checkCollision(draggedShape, matchingShape)) {
          draggedShape.style.left = matchingShape.style.left;
          draggedShape.style.top = matchingShape.style.top;
          draggedShape.style.display = 'none';
          matchingShape.style.display = 'none';
          createConfettiBurst(parseInt(matchingShape.style.left) + 50, parseInt(matchingShape.style.top) + 50);
          
          // Check if all shapes are matched
          if (allShapesMatched()) {
            setTimeout(resetGame, 1000); // Reset after 2 seconds to show the confetti
          }
        } else {
          // Keep the shape where it was dropped (stay at new position, no reset)
          draggedShape.style.position = 'absolute';
          draggedShape.style.zIndex = 0;
        }

        // Cleanup
        document.removeEventListener('touchmove', handleDragMove);
        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('touchend', handleDragEnd);
        document.removeEventListener('mouseup', handleDragEnd);
      }
    });
  </script>
</body>
</html>
