<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GitHub Messaging App</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@octokit/core@5.0.0/dist/index.umd.min.js"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      max-width: 800px; 
      margin: 0 auto; 
      padding: 20px; 
      line-height: 1.6; 
    }
    .section { 
      border: 1px solid #ddd; 
      padding: 15px; 
      margin-bottom: 20px; 
      background-color: #f9f9f9; 
    }
    #jsonEditor { 
      width: 100%; 
      resize: vertical; 
    }
    #postContainer .postBox { 
      border: 1px solid #e1e4e8; 
      margin-bottom: 10px; 
      padding: 10px; 
    }
    .guide { 
      background-color: #f0f0f0; 
      border-left: 4px solid #007bff; 
      padding: 10px; 
      margin-bottom: 20px; 
    }
  </style>
</head>
<body>
  <h1>GitHub Messaging App</h1>
  <!-- Log in with GitHub -->
  <a id="loginButton" href="https://github.com/login/oauth/authorize?client_id=Ov23liLwfabESq6mUMOq&scope=repo&redirect_uri=https://luminafieldsnz.github.io/Lumina/tools/message/index.html">
    Log in with GitHub
  </a>

  <div class="guide">
    <h2>App Usage Guide</h2>
    <ol>
      <li><strong>Upload JSON:</strong> Upload configuration with access token and hash groups</li>
      <li><strong>JSON Editor:</strong> Modify configuration directly</li>
      <li><strong>Add Hash Groups:</strong> Create new hash groups for message categorization</li>
      <li><strong>Search Messages:</strong> Find messages by hash group</li>
      <li><strong>Submit Messages:</strong> Create new GitHub issues as messages</li>
    </ol>
  </div>

  <!-- JSON File Upload -->
  <div class="section">
    <h2>JSON Configuration</h2>
    <input type="file" id="jsonUpload" accept="application/json" />
    <button onclick="handleFileUpload()">Upload JSON</button>

    <h3>JSON Editor</h3>
    <textarea id="jsonEditor" rows="10" placeholder="Paste your JSON configuration here"></textarea>
    <button onclick="updateJsonConfiguration();searchGitHubPosts();">Update Configuration</button>
  </div>

  <!-- Add Hash Group -->
  <div class="section">
    <h2>Add Hash Group</h2>
    <input type="text" id="newHashGroup" placeholder="Enter new hash group (e.g., #NewGroup)">
    <input type="text" id="newKey" placeholder="Enter decryption key">
    <button onclick="addHashGroup()">Add Hash Group</button>
  </div>

  <!-- Search Posts -->
  <div class="section">
    <h2>Search Messages</h2>
    <input type="text" id="hashGroup" placeholder="Enter hash group" value="#DefaultGroup">
    <input type="text" id="decryptionKey" placeholder="Decryption Key (Optional)">
    <button onclick="searchGitHubPosts()">Search Messages</button>
    <button onclick="decryptMessages()">Decrypt Messages</button>
  </div>

  <!-- Message Submission -->
  <div class="section">
    <h2>Submit Message</h2>
    <input type="text" id="messageSubject" placeholder="Enter message subject">
    <textarea id="messageBody" placeholder="Enter encrypted message body"></textarea>
    <input type="text" id="encryptionKey" placeholder="Encryption Key">
    <button onclick="submitGitHubIssue()">Submit Message</button>
  </div>

  <!-- Display Posts -->
  <div id="postContainer"></div>

  <script>
    let token = ''; // Token will be dynamically set after login
    let jsonData = {
      monthAccess: '',
      hashGroups: [
        { hash: '#DefaultGroup', key: 'DefaultKey' }
      ]
    };
  
    // Function to retrieve client credentials securely
    // This should be replaced with a secure way to fetch these credentials
    async function getClientCredentials() {
      // Example: Fetching client credentials from a secure server-side API
      // (this should be done securely on the server and not in the client-side code)
      try {
        const response = await fetch('/get-client-credentials');
        const credentials = await response.json();
        return credentials;
      } catch (error) {
        console.error("Error fetching client credentials:", error);
        alert("Failed to retrieve client credentials.");
      }
    }
  
    // Handle GitHub login
    async function handleGitHubLogin() {
      const credentials = await getClientCredentials(); // Fetch client credentials
  
      if (!credentials) {
        alert('Unable to retrieve client credentials.');
        return;
      }
  
      const clientId = credentials.client_id;  // Dynamically set client_id
      const redirectUri = 'https://luminafieldsnz.github.io/Lumina/tools/message/index.html';
      const scope = 'repo'; // Access scope for private repositories
      const authUrl = `https://github.com/login/oauth/authorize?client_id=${clientId}&scope=${scope}&redirect_uri=${redirectUri}`;
  
      window.location.href = authUrl; // Redirect user to GitHub login
    }
  
    // Handle GitHub OAuth callback
    async function handleOAuthCallback() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code'); // Retrieve the code from the URL
  
      if (code) {
        const credentials = await getClientCredentials(); // Fetch client credentials dynamically
  
        if (!credentials) {
          alert('Unable to retrieve client credentials.');
          return;
        }
  
        const { client_id, client_secret } = credentials; // Dynamically set client_id and client_secret
  
        try {
          const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
            method: 'POST',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              client_id: client_id,  // Use dynamically fetched client_id
              client_secret: client_secret,  // Use dynamically fetched client_secret
              code: code, // The code returned by GitHub
              redirect_uri: 'https://luminafieldsnz.github.io/Lumina/tools/message/index.html' // Your registered redirect URI
            })
          });
  
          const tokenData = await tokenResponse.json(); // Get the response data
  
          if (tokenData.access_token) {
            // If the access token is returned, store it and alert the user
            token = tokenData.access_token;
            localStorage.setItem('githubToken', token);
            alert('Logged in successfully!');
          } else {
            // If no access token is returned, alert the user
            alert('Failed to authenticate with GitHub.');
          }
        } catch (error) {
          console.error('OAuth callback error:', error);
          alert('Login process encountered an error.');
        }
      }
    }
  
    // Check for OAuth callback and handle token
    if (window.location.search.includes('code=')) {
      handleOAuthCallback(); // If the URL contains the "code" parameter, proceed with handling the callback
    }
  
    // Handle file upload
    async function searchGitHubPosts() {
  const container = document.getElementById('postContainer');
  container.innerHTML = ''; // Clear previous results

  try {
    // Log the current hashGroups in jsonData
    console.log('Searching with the following hash groups:', jsonData.hashGroups);

    // Loop through all hashGroups in the JSON data
    for (const group of jsonData.hashGroups) {
      // Construct the search query based on multiple fields
      const searchQuery = `${encodeURIComponent(group.hash)}+${encodeURIComponent(group.key)}+type:issue+in:title`;
      console.log('Search Query:', searchQuery); // Log the search query for debugging

      // Perform the search on GitHub API
      const url = `https://api.github.com/search/issues?q=${searchQuery}`;
      console.log('Fetching GitHub posts from URL:', url); // Log the API request URL

      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      // Log the response status and check if it's successful
      console.log('GitHub API Response Status:', response.status);
      if (response.status === 401) {
        alert("Unauthorized! Please check your GitHub token.");
        return;
      }

      const data = await response.json();

      // Log the response data to check the results
      console.log('GitHub API Response Data:', data);

      if (data.items && data.items.length > 0) {
        displayPosts(data.items); // Display posts if any are found
      } else {
        console.log('No posts found for this search query:', searchQuery); // Log if no posts found
      }
    }

    if (container.children.length === 0) {
      console.log("No posts found for any hash groups.");
      alert("No posts found for any hash groups.");
    }
  } catch (error) {
    console.error('Error fetching GitHub posts:', error);
  }
}

  
    // Update JSON configuration
    function updateJsonConfiguration() {
      try {
        const editorContent = document.getElementById('jsonEditor').value;
        jsonData = JSON.parse(editorContent);
  
        token = jsonData.monthAccess;
  
        if (!token) {
          alert('No valid GitHub token found in the configuration.');
          return;
        }
  
        alert('Configuration updated successfully!');
      } catch (e) {
        console.error(e);
        alert('Invalid JSON configuration. Please check your syntax.');
      }
    }
  
    // Add a new hash group
    function addHashGroup() {
      const newHashGroup = document.getElementById('newHashGroup').value;
      const newKey = document.getElementById('newKey').value;
  
      if (newHashGroup && newKey) {
        jsonData.hashGroups.push({
          hash: newHashGroup,
          key: newKey
        });
        document.getElementById('jsonEditor').value = JSON.stringify(jsonData, null, 2);
        alert('New hash group added!');
      } else {
        alert('Please provide both a hash group and key.');
      }
    }
  
    // Search GitHub posts by hash group
    async function searchGitHubPosts() {
  const container = document.getElementById('postContainer');
  container.innerHTML = ''; // Clear previous results

  try {
    // Loop through all hashGroups in the JSON data
    for (const group of jsonData.hashGroups) {
      // Construct a more specific search query based on multiple fields
      const searchQuery = `${encodeURIComponent(group.hash)}+${encodeURIComponent(group.key)}+type:issue+in:title`;

      // Perform the search on GitHub API
      const url = `https://api.github.com/search/issues?q=${searchQuery}`;

      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      if (response.status === 401) {
        alert("Unauthorized! Please check your GitHub token.");
        return;
      }

      const data = await response.json();

      if (data.items && data.items.length > 0) {
        displayPosts(data.items); // Display posts if any are found
      }
    }

    if (container.children.length === 0) {
      alert("No posts found for any hash groups.");
    }
  } catch (error) {
    console.error('Error fetching GitHub posts:', error);
  }
}


async function submitGitHubIssue() {
  const title = document.getElementById('messageSubject').value;
  const body = document.getElementById('messageBody').value;
  const encryptionKey = document.getElementById('encryptionKey').value;

  if (!title || !body) {
    alert('Please provide both a subject and a body for the message.');
    return;
  }

  // Encrypt body if encryption key is provided
  const processedBody = encryptionKey 
    ? CryptoJS.AES.encrypt(body, encryptionKey).toString()
    : body;

  try {
    // Create Octokit instance with the token
    const octokit = new Octokit({ auth: token });

    // Submit issue
    const response = await octokit.request('POST /repos/{owner}/{repo}/issues', {
      owner: 'MFGLife',      // Confirm this is exactly correct
      repo: 'Messages',      // Note the capitalization - case sensitive!
      title: title,
      body: processedBody,
      headers: {
        'X-GitHub-Api-Version': '2022-11-28'
      }
    });

    alert('Message submitted successfully!');
    console.log('Created Issue:', response.data);

    // Clear input fields
    document.getElementById('messageSubject').value = '';
    document.getElementById('messageBody').value = '';
    document.getElementById('encryptionKey').value = '';

  } catch (error) {
    console.error('Issue submission error:', error);
    alert(`Failed to submit message: ${error.message}`);
  }
}
  
    // Display GitHub posts
    function displayPosts(posts) {
      const container = document.getElementById('postContainer');
      container.innerHTML = '';
  
      posts.forEach((post) => {
        const postElement = document.createElement('div');
        postElement.classList.add('postBox');
        postElement.innerHTML = `
          <h3><a href="${post.html_url}" target="_blank">${post.title}</a></h3>
          <p><strong>Platform:</strong> GitHub Issue</p>
          <p><strong>Encrypted Content:</strong> ${post.body}</p>
        `;
        container.appendChild(postElement);
      });
    }
  
    // AES decryption (for any encrypted posts)
    function aesDecrypt(encryptedMessage, key) {
      const decrypted = CryptoJS.AES.decrypt(encryptedMessage, key);
      return decrypted.toString(CryptoJS.enc.Utf8);
    }
  

  </script>
  
  


</body>
</html>
